/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Member = Connection | Field;

export const Member = 'Member';

export function isMember(item: unknown): item is Member {
    return reflection.isInstance(item, Member);
}

export type QualifiedName = string;

export interface Connection extends AstNode {
    readonly $container: Entity;
    readonly $type: 'Connection';
    kind: Kind
    name: string
    to: Reference<Entity>
}

export const Connection = 'Connection';

export function isConnection(item: unknown): item is Connection {
    return reflection.isInstance(item, Connection);
}

export interface Document extends AstNode {
    readonly $type: 'Document';
    entities: Array<Entity>
    imports: Array<Import>
    package: QualifiedName
}

export const Document = 'Document';

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document);
}

export interface Field extends AstNode {
    readonly $container: Entity;
    readonly $type: 'Field';
    name: string
    type: Type
}

export const Field = 'Field';

export function isField(item: unknown): item is Field {
    return reflection.isInstance(item, Field);
}

export interface Import extends AstNode {
    readonly $container: Document;
    readonly $type: 'Import';
    path: QualifiedName
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Kind extends AstNode {
    readonly $container: Connection;
    readonly $type: 'Kind';
    kindType: 'consistOf' | 'has' | 'partOf'
}

export const Kind = 'Kind';

export function isKind(item: unknown): item is Kind {
    return reflection.isInstance(item, Kind);
}

export interface NamedElement extends AstNode {
    readonly $container: Document;
    readonly $type: 'Entity' | 'NamedElement';
    name: string
}

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export interface Type extends AstNode {
    readonly $container: Field;
    readonly $type: 'Type';
    dataType: 'Bool' | 'Int' | 'String'
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface Entity extends NamedElement {
    readonly $container: Document;
    readonly $type: 'Entity';
    members: Array<Member>
    name: string
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface TinyDslAstType {
    Connection: Connection
    Document: Document
    Entity: Entity
    Field: Field
    Import: Import
    Kind: Kind
    Member: Member
    NamedElement: NamedElement
    Type: Type
}

export class TinyDslAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Connection', 'Document', 'Entity', 'Field', 'Import', 'Kind', 'Member', 'NamedElement', 'Type'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Connection:
            case Field: {
                return this.isSubtype(Member, supertype);
            }
            case Entity: {
                return this.isSubtype(NamedElement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Connection:to': {
                return Entity;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Document': {
                return {
                    name: 'Document',
                    mandatory: [
                        { name: 'entities', type: 'array' },
                        { name: 'imports', type: 'array' }
                    ]
                };
            }
            case 'Entity': {
                return {
                    name: 'Entity',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new TinyDslAstReflection();
